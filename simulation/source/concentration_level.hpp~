//
//  con_level.cpp
//
//
//  Created by aylab on 7/18/16.
//
//
#ifndef CONCENTRATION_LEVEL_HPP
#define CONCENTRATION_LEVEL_HPP
#include <stdlib.h>
#include <cuda.h>
#include <iostream>
#include "macros.hpp"

template<class T>
class concentration_level{
public:
    
    class cell{
    public:
        __host__ __device__ cell(T *row, bool cuda): _array(row), _cuda(cuda) {}
        __host__ __device__ T& operator[](int k){
			if (_cuda){return _darray[k];}
			else{return _array[k];}
		}
        __host__ __device__ const T& operator[](int k) const {
			if (_cuda){return _darray[k];}
			else{return _array[k];}
		}
        T *_array;
		T *_darray;
		bool _cuda;
    };


    class timespan{
    public:
        __host__ __device__ timespan(T *plane,int width, bool cuda): _array(plane), _width(width), _cuda(cuda){};
        __host__ __device__ cell operator[](int j) {
            if (_cuda){
				cell temp(_darray+_width*j, _cuda);
       			return temp;
			}		
			else{
				cell temp(_array+_width*j, _cuda);
        		return temp;
			}
        }

        __host__ __device__ const cell operator[](int j) const{
            if (_cuda){
				cell temp(_darray+_width*j, _cuda);
       			return temp;
			}		
			else{
				cell temp(_array+_width*j, _cuda);
        		return temp;
			}
        }
        T *_array;
		T *_darray;
		bool _cuda;
        int _width;
    };
    concentration_level(int height =0, int length =0, int width =0)
		:_height(height),_length(length),_width(width),_cuda(false){
        allocate_array();
    }
    
    concentration_level(const concentration_level<T>& other)
		:_height(other._height),_length(other._length),_width(other._width),_cuda(other._cuda){
        allocate_array();
        for (int he=0; he< _height; he++){
            for (int le=0; le< _length; le++){
                for (int wi=0; wi< _width; wi++){
                    _array[he*_length*_width+le*_width+wi]=other._array[he*_length*_width+le*_width+wi];
					_darray[he*_length*_width+le*_width+wi]=other._darray[he*_length*_width+le*_width+wi];
                }
            }
        }
    }
    
    void initialize(int height, int length, int width){
        dealloc_array();
        _width=width;
        _height=height;
        _length=length;
		_cuda=false;
        allocate_array();
        reset();
    }
    
    void reset(){
        for (int i = 0; i < _height; i++) {
            for (int j = 0; j < _length; j++) {
                for (int k = 0; k < _width; k++) {
                    _array[i*_length*_width+j*_width+k] = 0; // Initialize every concentration level at every time step for every cell to 0
					
                }
            }
        }
    }
    
	/*
	concentration_level& operator=(const concentration_level& other){
        dealloc_array();
        _height=other._height;
        _length=other._length;
        _width=other._width;
        allocate_array();
        for (int he; he< _height; he++){
            for (int le; le< _length; le++){
                for (int wi; wi< _width; wi++){
                    _array[he*_length*_width+le*_width+wi]=other._array[he*_length*_width+le*_width+wi];
                }
            }
        }
        return *this;
    }
    */
	__host__ __device__ timespan operator[](int i){
		if (_cuda){
			timespan temp(_darray+_length*_width*i, _width, _cuda);
       		return temp;
		}		
		else{
			timespan temp(_array+_length*_width*i, _width, _cuda);
        	return temp;
		}		
	}
	
    __host__ __device__ const timespan operator[](int i) const{
		if (_cuda){
			timespan temp(_darray+_length*_width*i, _width, _cuda);
       		return temp;
		}		
		else{
			timespan temp(_array+_length*_width*i, _width, _cuda);
        	return temp;
		}		
	}
    
    ~concentration_level() {
        dealloc_array();
    }
    
    int height() const {return _height;}
    int length() const {return _length;}
    int width() const {return _width;}
    __host__ __device__ bool getStatus() { return _cuda; }

	void toGPU(){
		if(!_cuda){
			return;
		}	
		int size = _height*_length*_width* sizeof(T);
		cudaMalloc((void**)&_darray, size);
		cudaMemcpy(_darray,_array,size,cudaMemcpyHostToDevice);
		_cuda=true;
	}

	void toCPU(){
		if(!_cuda){
			return;
		}
		int size = _height*_length*_width* sizeof(T);
		cudaMemcpy(_array, _darray, size, cudaMemcpyDeviceToHost);
		cudaFree(_darray);
		_darray = NULL;
		_cuda= false;
	}
protected:
    void dealloc_array(){
        if (_array){
            delete[] _array;
        }
        _array= NULL;
    }
	
    void allocate_array(){
        if (_width*_length*_height >0){
            _array= new T[_height*_length*_width];
			if (_array == NULL){std::cout<<"ERROR"<<endl; exit(EXIT_MEMORY_ERROR);}
        }
        else{
            _array= NULL;
		}
    }
    
    
    int   _height,_length, _width;
	bool _cuda;
    T *_array;
	T *_darray;
};
#endif
